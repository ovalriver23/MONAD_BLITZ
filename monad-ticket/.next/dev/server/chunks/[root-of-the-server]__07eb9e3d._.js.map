{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 40, "column": 0}, "map": {"version":3,"sources":["file:///Users/tuanamelisaaksoy/Desktop/Wh%C4%B1tePass%20V2/MONAD_BLITZ/monad-ticket/src/app/api/waitlist/route.ts"],"sourcesContent":["/**\n * In-memory waitlist store (replace with a DB in production).\n *\n * GET  /api/waitlist?address=0x...          → all entries for address\n * GET  /api/waitlist/[eventId]?address=0x.. → stats for event\n * POST /api/waitlist/[eventId]              → join\n * DELETE /api/waitlist/[eventId]            → leave\n */\n\nimport type { WaitlistEntry } from \"../../../types/waitlist\";\n\n// ---------------------------------------------------------------------------\n// Shared in-memory store (module-level singleton in dev)\n// ---------------------------------------------------------------------------\n\ninterface WaitlistStore {\n  entries: WaitlistEntry[];\n  nextId: number;\n}\n\nconst g = globalThis as typeof globalThis & { _waitlist?: WaitlistStore };\nif (!g._waitlist) g._waitlist = { entries: [], nextId: 1 };\nexport const store = g._waitlist;\n\n// ---------------------------------------------------------------------------\n// GET /api/waitlist?address=0x...\n// ---------------------------------------------------------------------------\n\nexport async function GET(request: Request) {\n  const { searchParams } = new URL(request.url);\n  const address = searchParams.get(\"address\")?.toLowerCase();\n\n  if (!address) {\n    return Response.json(\n      { error: \"address query param required\" },\n      { status: 400 }\n    );\n  }\n\n  const entries = store.entries.filter(\n    (e) => e.userAddress.toLowerCase() === address && e.status === \"waiting\"\n  );\n\n  return Response.json(entries);\n}\n"],"names":[],"mappings":"AAAA;;;;;;;CAOC;;;;;;AAaD,MAAM,IAAI;AACV,IAAI,CAAC,EAAE,SAAS,EAAE,EAAE,SAAS,GAAG;IAAE,SAAS,EAAE;IAAE,QAAQ;AAAE;AAClD,MAAM,QAAQ,EAAE,SAAS;AAMzB,eAAe,IAAI,OAAgB;IACxC,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;IAC5C,MAAM,UAAU,aAAa,GAAG,CAAC,YAAY;IAE7C,IAAI,CAAC,SAAS;QACZ,OAAO,SAAS,IAAI,CAClB;YAAE,OAAO;QAA+B,GACxC;YAAE,QAAQ;QAAI;IAElB;IAEA,MAAM,UAAU,MAAM,OAAO,CAAC,MAAM,CAClC,CAAC,IAAM,EAAE,WAAW,CAAC,WAAW,OAAO,WAAW,EAAE,MAAM,KAAK;IAGjE,OAAO,SAAS,IAAI,CAAC;AACvB"}},
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":["file:///Users/tuanamelisaaksoy/Desktop/Wh%C4%B1tePass%20V2/MONAD_BLITZ/monad-ticket/src/app/api/waitlist/%5BeventId%5D/route.ts"],"sourcesContent":["import { store } from \"../route\";\nimport type { WaitlistEntry, WaitlistStats } from \"../../../../types/waitlist\";\n\ninterface Params {\n  params: Promise<{ eventId: string }>;\n}\n\n// ---------------------------------------------------------------------------\n// GET /api/waitlist/[eventId]?address=0x...\n// ---------------------------------------------------------------------------\n\nexport async function GET(request: Request, { params }: Params) {\n  const { eventId } = await params;\n  const id = parseInt(eventId);\n  const { searchParams } = new URL(request.url);\n  const address = searchParams.get(\"address\")?.toLowerCase();\n\n  const waiting = store.entries.filter(\n    (e) => e.eventId === id && e.status === \"waiting\"\n  );\n\n  const userEntry = address\n    ? waiting.find((e) => e.userAddress.toLowerCase() === address)\n    : undefined;\n\n  const stats: WaitlistStats = {\n    eventId: id,\n    totalWaiting: waiting.length,\n    userPosition: userEntry ? userEntry.position : undefined,\n  };\n\n  return Response.json(stats);\n}\n\n// ---------------------------------------------------------------------------\n// POST /api/waitlist/[eventId] — join waitlist\n// ---------------------------------------------------------------------------\n\nexport async function POST(request: Request, { params }: Params) {\n  const { eventId } = await params;\n  const id = parseInt(eventId);\n  const { address } = await request.json();\n\n  if (!address) {\n    return Response.json({ error: \"address required\" }, { status: 400 });\n  }\n\n  const alreadyIn = store.entries.find(\n    (e) =>\n      e.eventId === id &&\n      e.userAddress.toLowerCase() === address.toLowerCase() &&\n      e.status === \"waiting\"\n  );\n\n  if (alreadyIn) {\n    return Response.json({ error: \"Already on waitlist\" }, { status: 409 });\n  }\n\n  const position =\n    store.entries.filter((e) => e.eventId === id && e.status === \"waiting\")\n      .length + 1;\n\n  const entry: WaitlistEntry = {\n    id: String(store.nextId++),\n    eventId: id,\n    userAddress: address.toLowerCase(),\n    joinedAt: new Date().toISOString(),\n    position,\n    status: \"waiting\",\n  };\n\n  store.entries.push(entry);\n  return Response.json(entry, { status: 201 });\n}\n\n// ---------------------------------------------------------------------------\n// DELETE /api/waitlist/[eventId] — leave waitlist\n// ---------------------------------------------------------------------------\n\nexport async function DELETE(request: Request, { params }: Params) {\n  const { eventId } = await params;\n  const id = parseInt(eventId);\n  const { address } = await request.json();\n\n  const idx = store.entries.findIndex(\n    (e) =>\n      e.eventId === id &&\n      e.userAddress.toLowerCase() === address.toLowerCase() &&\n      e.status === \"waiting\"\n  );\n\n  if (idx === -1) {\n    return Response.json({ error: \"Not on waitlist\" }, { status: 404 });\n  }\n\n  store.entries.splice(idx, 1);\n\n  // Re-rank remaining entries for this event\n  let pos = 1;\n  store.entries\n    .filter((e) => e.eventId === id && e.status === \"waiting\")\n    .sort(\n      (a, b) => new Date(a.joinedAt).getTime() - new Date(b.joinedAt).getTime()\n    )\n    .forEach((e) => {\n      e.position = pos++;\n    });\n\n  return new Response(null, { status: 204 });\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;;AAWO,eAAe,IAAI,OAAgB,EAAE,EAAE,MAAM,EAAU;IAC5D,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM;IAC1B,MAAM,KAAK,SAAS;IACpB,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;IAC5C,MAAM,UAAU,aAAa,GAAG,CAAC,YAAY;IAE7C,MAAM,UAAU,iJAAK,CAAC,OAAO,CAAC,MAAM,CAClC,CAAC,IAAM,EAAE,OAAO,KAAK,MAAM,EAAE,MAAM,KAAK;IAG1C,MAAM,YAAY,UACd,QAAQ,IAAI,CAAC,CAAC,IAAM,EAAE,WAAW,CAAC,WAAW,OAAO,WACpD;IAEJ,MAAM,QAAuB;QAC3B,SAAS;QACT,cAAc,QAAQ,MAAM;QAC5B,cAAc,YAAY,UAAU,QAAQ,GAAG;IACjD;IAEA,OAAO,SAAS,IAAI,CAAC;AACvB;AAMO,eAAe,KAAK,OAAgB,EAAE,EAAE,MAAM,EAAU;IAC7D,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM;IAC1B,MAAM,KAAK,SAAS;IACpB,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,QAAQ,IAAI;IAEtC,IAAI,CAAC,SAAS;QACZ,OAAO,SAAS,IAAI,CAAC;YAAE,OAAO;QAAmB,GAAG;YAAE,QAAQ;QAAI;IACpE;IAEA,MAAM,YAAY,iJAAK,CAAC,OAAO,CAAC,IAAI,CAClC,CAAC,IACC,EAAE,OAAO,KAAK,MACd,EAAE,WAAW,CAAC,WAAW,OAAO,QAAQ,WAAW,MACnD,EAAE,MAAM,KAAK;IAGjB,IAAI,WAAW;QACb,OAAO,SAAS,IAAI,CAAC;YAAE,OAAO;QAAsB,GAAG;YAAE,QAAQ;QAAI;IACvE;IAEA,MAAM,WACJ,iJAAK,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,IAAM,EAAE,OAAO,KAAK,MAAM,EAAE,MAAM,KAAK,WAC1D,MAAM,GAAG;IAEd,MAAM,QAAuB;QAC3B,IAAI,OAAO,iJAAK,CAAC,MAAM;QACvB,SAAS;QACT,aAAa,QAAQ,WAAW;QAChC,UAAU,IAAI,OAAO,WAAW;QAChC;QACA,QAAQ;IACV;IAEA,iJAAK,CAAC,OAAO,CAAC,IAAI,CAAC;IACnB,OAAO,SAAS,IAAI,CAAC,OAAO;QAAE,QAAQ;IAAI;AAC5C;AAMO,eAAe,OAAO,OAAgB,EAAE,EAAE,MAAM,EAAU;IAC/D,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM;IAC1B,MAAM,KAAK,SAAS;IACpB,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,QAAQ,IAAI;IAEtC,MAAM,MAAM,iJAAK,CAAC,OAAO,CAAC,SAAS,CACjC,CAAC,IACC,EAAE,OAAO,KAAK,MACd,EAAE,WAAW,CAAC,WAAW,OAAO,QAAQ,WAAW,MACnD,EAAE,MAAM,KAAK;IAGjB,IAAI,QAAQ,CAAC,GAAG;QACd,OAAO,SAAS,IAAI,CAAC;YAAE,OAAO;QAAkB,GAAG;YAAE,QAAQ;QAAI;IACnE;IAEA,iJAAK,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK;IAE1B,2CAA2C;IAC3C,IAAI,MAAM;IACV,iJAAK,CAAC,OAAO,CACV,MAAM,CAAC,CAAC,IAAM,EAAE,OAAO,KAAK,MAAM,EAAE,MAAM,KAAK,WAC/C,IAAI,CACH,CAAC,GAAG,IAAM,IAAI,KAAK,EAAE,QAAQ,EAAE,OAAO,KAAK,IAAI,KAAK,EAAE,QAAQ,EAAE,OAAO,IAExE,OAAO,CAAC,CAAC;QACR,EAAE,QAAQ,GAAG;IACf;IAEF,OAAO,IAAI,SAAS,MAAM;QAAE,QAAQ;IAAI;AAC1C"}}]
}